đồ thị là mô hình dùng để biểu diễn một tập các đối tượng và mối quan hệ giữa các đối tượng

Kí hiệu G <V,E>
2/ Khái niệm
a) cạnh liên thuộc , đỉnh kề , bậc
+) Xét đồ thị G = <V,E>
định v thuộc V thì cạnh c được gọi là cạnh liên thuộc của 2 đỉnh u , v
cạnh e = (u,v) và u dgl đỉnh kề của v và ngược lại
+) Bậc cuả đỉnh u kí hiệu Deg (u) : là số cạnh liên thuộc của y . Nó cũng là số đỉnh kề với u
*bậc lẻ số đỉnh lề với u là số lẻ

* Định lý 1 : Trong đồ thị G <V,E>
thì tổng v thuộc V = 2 |E|
Hệ quả : Trong đồ thị vô hướng tổng các đỉnh bậc lẻ là số chẵn .
* Đinh lý 2 : Trong đồ thị có hướng tổng tất cả các bán bậc vào của đỉnh bằng tổng tất cả
		bán bậc ra của đỉnh và bằng số cạnh
	Tổng DEG+(v) = tổng Deg-(v) = |E|
b) Đường đi và chu trình 
-Một dãy p , p1, p2 , p 3 ,.., pk. Mỗi cạnh xuất hiện môt lần
trong đó (p1,pi-1) thuộc E (0 <i < k) thì dãy p0 , p1 , p2,...,pk đgl một đường đi dơn .
-Một đường đi đơn có đỉnh đầu po và đỉnh cuối pk (k >= 3) trùng nhau thì dgl một chu trình
c) Một số khái niệm khác
+) Đồ thị vô hướng liên thông là đồ thị mà bất kì 2 đỉnh nào đều có đường đi giữa chúng
+) Đồ thị có hướng có 2 khái niệm liên thông
	* Liên thông mạnh : bất kì 2 đỉnh nào đều đó đường đi
	* Liên thông yếu : Phiên bảo vô hướn của nó là liên thông 
- Đồ thị vô hướng đầy đủ là đồ thị mà tất cả mọi cặp đỉnh đều có cạnh nối giữa chúg
* đồ thị vô hướng đầy đủ có n đỉnh thì n * (n-1) / 2 cạnh bậc n-1
- Cây là đồ thị ko có chu trình 

--------------------
 Biểu diễn đồ thị
1 ) Ma trận kề với G < V,E> , |V| = n 
- Đánh số thứ tự các đỉnh từ 1 đến n 
_ Dùng ma trận A nxn để biểu diễn đồ thị 
	Aij = { 1 nếu có cạnh (i,j) 
	      { 0 nếu ko có cạnh (i,j)
Mỗi cạnh có trọng số thì Aij trọng số của cạnh

* Nếu G là vô hướng thì ma trận A đối xứng qua đường chéo chính Aij = Aji
ưu điểm nhược điểm ...
2 ) Danh sách cạnh 
 xĐối với G <V, E> , |v| = n , | E | = m ;
thì ta có thể dùng một danh sách có m phần tử mỗi phaafn tử lad 1 cặp số (u,v) để biểu diễn
* Ưu điểm : Tiết kiệm bộ nhớ với đồ thị thưa
	  : Dễ  trong phép duyệt cạnh
* Nhuocj điểm  khó duyệt đỉnh , khó kiểm tra tính kề
3) Danh sách kề
* Sử dụng 2 mảng 1 chiều 
- H1, H2,..., Hn trong đó mỗi phần tử là một đỉnh lưu trữ chỉ số của các đỉnh lân cận 
- A1,A2, ..., An danh sách casc đỉnh 
 * Đỉnh kề với đỉnh u trong H là các đỉnh từ A[h[u-1]+ 1] đến đỉnh A[h[u]]
------------------------------------------
PHÉP DUYỆT ĐỒ THỊ
1) Duyêt theo chieedu sâu (DFS) 
Thuật toán 
b1 : Thăm đỉnh u 
b2 : với mọi đỉnh u 
2) Duyệt theo chiều rộng (BFS) 
Thuật toán 
b1: xuất phát từ đỉnh u 
b2: Thăm đỉnh u 
b3 : thăm các đỉnh v kề với u nếu v chưa thăm
b4: thăm các đỉnh còn lại chưa thăm 
-----------------------------------------
BÀI TOÁN TÌM ĐƯỜNG ĐI NGẮN NHẤT

1) Bài toán
 	Cho đồ thị G = < V,E> , |V| = n , |E| = m  và hai đỉnh s, t;
	Yêu cầu : Hãy tìm đường đi có tổng trọng số nhỏ nhất từ s đến t
2)  Thuật toán Floyd
Gọi Dij la tong trog so be nhat cua duong di tu i -> j . Neu ko co đường đi i -> j thì Dij = oo

vd gọi pij là đỉnh trung gian đến đường đi đó đỉnh i đến đỉnh j trên đường i -> j . Nếu pij = 0 thì i và j là 2 đỉnh kề nhau 

* Ý nghĩa Nếu tồn tại một đỉnh k trên đường đi từ i -> j mà tổng đường đi từ i đến k và từ k đến j nhỏ hơn đường đi từ i -> j hay cập nhật lại Dij = Dik + Dkj , Pij = k ;
* Thuật toán 
	B1 : Khơi tạo : Dij = 	{ oo Nếu i,j ko kề nhau
			      	{ Gij Nếu i , j kề nhau
				{ 0 Nếu i trùng j
			Pij = 0 . Nếu i ,j  là cạnh
	B2 : Vập nhật lại trọng số và đường đi 
		for( k = 1 -> n)
			for (i = 1 -> n )
				for (j = 1 -> n ) 
					if (Dik + Dkj < Dij) Dij = Dik + Dkj , Pij = k ;
	B3 : Tìm đường đi từ s đến t 
		Void Path (int i , int j )
		{
			if ( pij == 0 ) return n ;
			else 
			{
				path(i , pij) 
				cout << pij << " ";
				path(pij,j);
			}
		}
3) Thuật toán dijsktra
 * Ý tưởng 
Gọi li là độ dài đường đi ngắn nhất từ s đến u -> cần tìm lt
b1 : Giải ls = 0 , lv = g[s][v] với mọi v thuộc V \ {s}
b2 : Tìm đỉnh u có lu nhỏ nhất
b3 : với mọi đỉnh v thuoc |V| nếu :lu + guv < lv thì cập nhật lại lv = lu + guv
b4 : Loại đỉnh u ra khỏi đồ thị V = V \{u}
b5 : Quay lại b2 cho đế khi V ={ rỗng}
* Cài đặt
gij : lưu cạnh (i,j)
Ci : đánh dấu các đỉnh thuộc đồ thị
tri : lưu đỉnh kề trc đỉh i tren đường đi s-> t
li : lưu nhãn tổng độ dài ngắn nhất trên đường đi s đến t 
void dijskrea()
{
	* khoi tạo *
	for (int i = 1 ;i <= n ; i++)
	{
		li = gsi ;
		ci = false;
		Tri = s;
	}
	Ls = 0 , trs = 0 ;
	* Cập nhật nhãn lại các đỉnh "
	while (!ct)
	{
		u = minlab
		for (v = 1 ; v <= n ; v++)
			if (lu+ guv < lv ) lv = lu + guv , tr v = u ;
	} -> kq Lt
}
int minlab()
{
int v = 0 , mk = oo;
for (int i = 1 ; i <+ n ; i++)
if (!ci && li < ml) ml = li , v = i ;
retur v;
}
