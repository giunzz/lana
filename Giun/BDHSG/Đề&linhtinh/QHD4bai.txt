F[i] = F[i - 1] ..... 


VỚi bài toán hiện tại là bài toán F[i] thì sẽ dùng F[i] tính cho F[i + 1]


1. C11KM 

- Gọi F[i][j] là tổng số tiền nhỏ nhất để mua được toàn bộ i món hàng ban đầu, đồng thời hiện tại ta đang sở hữu j thẻ khuyến mãi.

- Khởi tạo F[i][j] = inf. (p[i] <= 300, N <= 1000. Tổng giá trị <= 300.000 ===> chọn inf > 300000)  

- Bài toán cơ sở: F[0][0] = 0. 



- Với bài toán F[i][j] hiện tại là một bài toán có nghĩa (F[i][j] != inf)
Đối với món hàng thứ i + 1. 

Cách 1: Dùng thẻ khuyến mãi (j > 0). F[i + 1][j - 1] = Min(F[i + 1][j - 1], F[i][j]).
Cách 2: Nếu p[i + 1] <= 100 => F[i + 1][j] = Min(F[i + 1][j], F[i][j] + p[i + 1]). 
        Nếu p[i + 1] > 100 => F[i + 1][j + 1] = Min(F[i + 1][j + 1], F[i][j] + p[i + 1]).  

- Đáp án bài toán ? Min{F[n][j]} với j từ 0 -> số lượng thẻ khuyến mãi tối đa. 


memset(F, inf, sizeof(F)); 
F[0][0] = 0; 
for (int i = 0; i < n; i++) {
  for (int j = 0; j <= i; j++) {
    if (F[i][j] != inf) {
       if (j > 0) {
         F[i + 1][j - 1] = min(F[i + 1][j - 1], F[i][j]);
       }
       if (p[i + 1] <= 100) {
         F[i + 1][j] = min(F[i + 1][j], F[i][j] + p[i + 1]);
       }
       else {
         F[i + 1][j + 1] = min(F[i + 1][j + 1], F[i][j] + p[i + 1]); 
       }
    }
  }
}




- Bài toán cơ sở: F[0][0] 

- F[i][j]. 

Cách 1: Dùng thẻ khuyến mãi để mua món thứ i. F[i][j] = Min(F[i][j], F[i - 1][j + 1])
Cách 2: Nếu dùng tiền mặt để mua món thứ i. 
+ Nếu p[i] <= 100. F[i][j] = Min(F[i][j], F[i - 1][j] + p[i])
+ Nếu p[i] > 100 && j > 0. F[i][j] = Min(F[i][j], F[i - 1][j - 1] + p[i]). 


ioipalind.
Ab3bd

b3bd => db3bd 


Ab3bd -> Adb3bd -> Adb3bdA

Bài toán Ab3bd có thể được tính dựa trên bài toán b3bd. 

- Nếu gọi F[i][j] là số lượng ký tự ít nhất cần thêm để biến được chuỗi s(i .. j) thành chuỗi đối xứng.

- Bài toán cơ sở: F[i][i] = 0.


- Xây dựng công thức: 

Đang xét bài toán F[i][j].

Nếu s[i] = s[j]: F[i][j] = F[i + 1][j - 1].

Nếu s[i] != s[j]: 


Chỉ cần thêm ký tự d vào đầu chuỗi ?

F[i][j] = F[i][j - 1] + 1 
F[i][j] = F[i + 1][j] + 1

===> F[i][j] = Min(F[i][j - 1] + 1, F[i + 1][j] + 1)

- Kết quả bài toán: F[1][n]



. EDIST. 

- Gọi F[i][j] là số lượng phép biến đổi ít nhất để biến i ký tự đầu tiên của chuỗi A thành j ký tự đầu tiên của chuỗi B. 

- F[0][j] = j. F[i][0] = i. 


- F[i][j]. 

. Trường hợp 1: Nếu A[i] = B[j] ==> F[i][j] = F[i - 1][j - 1]
. Trường hợp 2: Nếu A[i] <> B[j] ==> 

MOOD
TDN 

+ Để sử dụng phép Delete cho ký tự A[i]. Biến "MOO" => "TDN". MOOD => TDND. 
===> F[i - 1][j]. F[i][j] = F[i - 1][j] + 1. 

+ Để sử dụng phép Insert. Biến "MOOD" => "TD" ==> "TDN". Sử dụng 1 phép insert thêm ký tự N vào cuối chuỗi TD. ===> F[i][j] = F[i][j - 1] + 1. 

+ Để sử dụng phép Replace. Biến "MOO" => "TD". Lúc này chuỗi "MOOD" => "TDD". Replace ký tự D thành ký tự N. ===> F[i][j] = F[i - 1][j - 1] + 1. 


F[i][j] = Min(F[i - 1][j] + 1, F[i][j - 1] + 1, F[i - 1][j - 1] + 1). 


- Kết quả bài toán: F[N][M] với N là độ dài của chuỗi a và M là độ dài của chuỗi b. 


Deque. 






















